#! /usr/bin/env python
"""
This is a tool for processing Zeek scripts. It currently supports formatting
scripts according to codified rules (no optionas at all atm), and showing a
parse tree for the script.
"""
# pylint: disable=missing-function-docstring, missing-class-docstring
# pylint: disable=too-many-arguments, too-many-return-statements
# pylint: disable=too-many-branches, too-many-statements
# pylint: disable=too-many-instance-attributes, too-many-lines

import argparse
import inspect
import os
import sys

try:
    from tree_sitter import Language, Parser
except ImportError:
    print('This script requires the tree_sitter package.')
    sys.exit(1)

# Build and initialize the tree-sitter parser. This becomes a no-op when the
# parser needs no re-building. We specify the library build location and the
# language(s) to include.
Language.build_library('build/zeek-language.so', ['tree-sitter-zeek'])
ZEEK_LANGUAGE = Language('build/zeek-language.so', 'zeek')
ZEEK_PARSER = Parser()
ZEEK_PARSER.set_language(ZEEK_LANGUAGE)

class Node:
    """A subset of tree_sitter.Node.

    We use this to build a mutable clone of the tree-sitter parse tree,
    and add some convenience functions.
    """
    def __init__(self):
        self.children = []
        self.parent = None
        self.prev_sibling = None
        self.next_sibling = None
        self.start_byte = 0
        self.end_byte = 0
        self.start_point = (0, 0)
        self.end_point = (0, 0)
        self.is_named = False
        self.type = None

    def is_comment(self):
        return self.type and self.type.endswith('_comment')

    def is_post_comment(self):
        return self.type and self.type == 'zeekygen_prev_comment'


class NodeMapper:
    def __init__(self):
        self._map = {}

    def register(self, symbol_name, klass, addl_args=None):
        self._map[symbol_name] = (klass, addl_args or {})

    def get(self, symbol_name):
        # If we have an explicit mapping, use it:
        if symbol_name in self._map:
            return self._map[symbol_name]

        # Try deriving from symbol_name:
        self._find_class(symbol_name)

        if symbol_name in self._map:
            return self._map[symbol_name]

        # Last straw: a default formatter:
        return Formatter, {}

    def _find_class(self, symbol_name):
        """Locates a Formatter class based on a symbol name.

        For example, this will try to resolve symbol name " module_decl" as
        ModuleDeclFormatter. When found, adds a mapping to the internal _map.
        """
        name_parts = [part.title() for part in symbol_name.split('_')]
        derived = ''.join(name_parts) + 'Formatter'
        pred = lambda mem: inspect.isclass(mem) and mem.__name__ == derived
        classes = inspect.getmembers(sys.modules[__name__], pred)

        if classes:
            self._map[symbol_name] = (classes[0][1], {})

MAP = NodeMapper()


class OutputStream:
    """A column-aware wrapper for output streams."""
    def __init__(self, ostream):
        self._ostream = ostream
        self._col = 0 # 0-based column the next character goes into.

    def write(self, data):
        for chunk in data.splitlines(keepends=True):
            if chunk.endswith(b'\n'):
                # Remove any trailing whitespace
                chunk = chunk.rstrip() + b'\n'

            try:
                if self._ostream == sys.stdout:
                    self._ostream.buffer.write(chunk)
                else:
                    self._ostream.write(chunk)
            except BrokenPipeError:
                #  https://docs.python.org/3/library/signal.html#note-on-sigpipe:
                devnull = os.open(os.devnull, os.O_WRONLY)
                os.dup2(devnull, sys.stdout.fileno())
                sys.exit(1)

            self._col += len(chunk)
            if chunk.endswith(b'\n'):
                self._col = 0

    def get_column(self):
        return self._col


class Script:
    def __init__(self, fname, ofname=None):
        # The file name to read the Zeek script from
        self.name = fname
        # The file's full content
        self.source = None
        # The tree-sitter parse tree for the script
        self.tree = None
        # The root node of our cloned (and malleable) tree
        self.root = None
        # The output file name -- None if stdout
        self.ofname = ofname

    def parse(self):
        with open(self.name, 'rb') as hdl:
            self.source = hdl.read()
            self.tree = ZEEK_PARSER.parse(self.source)
            self._clone_tree()
            self._patchup_tree()

    def traverse(self):
        def visit(node):
            queue = [(node, 0)]
            while queue:
                node, indent = queue.pop(0)
                yield node, indent
                for child in reversed(node.children):
                    queue.insert(0, (child, indent+1))

        assert self.root is not None, 'call Script.parse() before Script.traverse()'
        for node, indent in visit(self.root):
            yield node, indent

    def __getitem__(self, key):
        return self.source.__getitem__(key)

    def format(self):
        assert self.root is not None, 'call Script.parse() before Script.format()'
        with open(self.ofname, 'wb') if self.ofname else sys.stdout as ostream:
            fclass, _ = Formatter.lookup(self.root)
            formatter = fclass(self, self.root, OutputStream(ostream))
            formatter.format()

    def _clone_tree(self):
        # The tree_sitter tree isn't malleable from Python. This clones it to a
        # tree of our own Node class that we can alter freely.
        def make_node(node):
            new_node = Node()
            new_node.start_byte, new_node.end_byte = node.start_byte, node.end_byte
            new_node.start_point, new_node.end_point = node.start_point, node.end_point
            new_node.is_named = node.is_named
            new_node.type = node.type

            for child in node.children:
                new_child = make_node(child)
                new_child.parent = new_node
                new_node.children.append(new_child)
                if len(new_node.children) > 1:
                    new_node.children[-2].next_sibling = new_node.children[-1]
                    new_node.children[-1].prev_sibling = new_node.children[-2]

            return new_node

        self.root = make_node(self.tree.root_node)

    def _patchup_tree(self):
        """Make any modifications to the syntax tree we require for our processing."""

        # Move any dangling zeekygen_prev_comments down into the tree so they
        # directly child-follow the node that the comment refers to. For
        # example, this turns ...
        #
        #       type (138.11,138.14)
        #           int (138.11,138.14)
        #           ; (138.14,138.15)
        #       zeekygen_prev_comment (138.19,139.0) '##< A comment explaining the int\n'
        #       zeekygen_prev_comment (139.19,140.0) '##< continuing here.\n'
        #
        # ... into this:
        #
        #       type (138.11,138.14)
        #           int (138.11,138.14)
        #           ; (138.14,138.15)
        #           zeekygen_prev_comment (138.19,139.0) '##< A comment explaining the int\n'
        #           zeekygen_prev_comment (139.19,140.0) '##< continuing here.\n'
        #
        for node, _ in self.traverse():
            idx = 0 # Iterate manually since not every iteration advances idx
            while idx < len(node.children):
                child = node.children[idx]
                # If this child is a ##< comment and the previous child has
                # children, move the comment down to the kid's kids.
                if (idx > 0 and child.type == 'zeekygen_prev_comment' and
                    node.children[idx-1].children):

                    # Cut out comment from sibling relationships:
                    child.prev_sibling.next_sibling = child.next_sibling
                    if child.next_sibling:
                        child.next_sibling.prev_sibling = child.prev_sibling

                    # Move comment to new location:
                    node.children.pop(idx)
                    node.children[idx-1].children.append(child)

                    # Adjust sibling relationship in new location:
                    if len(node.children[idx-1].children) > 1:
                        node.children[idx-1].children[-2].next_sibling = child
                        child.prev_sibling = node.children[idx-1].children[-2]
                else:
                    idx += 1


# ---- Symbol formatters -------------------------------------------------------

class Formatter:
    def __init__(self, script, node, ostream, indent=0, parent=None):
        self._script = script
        self._node = node
        self._ostream = ostream
        self._indent = indent

        # Child node index for iteration
        self._cidx = 0

        # Like tree_sitter.Node we use a parent/children structure, so a given
        # formatter can access formatting state in its surroundings.
        self.parent = parent
        self.prev = None # We currently need no self.next
        self.children = []

    def format(self):
        if self._node.children:
            self._format_children()
        else:
            self._format_token()

    def _next_child(self):
        try:
            node = self._node.children[self._cidx]
            self._cidx += 1
            return node
        except IndexError:
            return None

    def _format_child_impl(self, indent):
        node = self._next_child()

        fclass, addl_args = Formatter.lookup(node)
        formatter = fclass(self._script, node, self._ostream,
                           indent=self._indent + int(indent),
                           parent=self, **addl_args)

        if self.children:
            formatter.prev = self.children[-1]
        self.children.append(formatter)

        formatter.format()

    def _format_child(self, indent=False):
        # Skip comments transparently, as they can occur anywhere.
        while self._is_comment():
            self._format_child_impl(indent=indent)

        self._format_child_impl(indent=indent)

        # After the child, also skip Zeekygen post-comments (##<):
        while self._is_post_comment():
            self._format_child_impl(indent=indent)
            if self._is_post_comment():
                self._write_nl()

    def _format_child_range(self, num, indent=False):
        for _ in range(num):
            self._format_child(indent)

    def _format_children(self, sep=None, final=None):
        while self._children_remaining():
            self._format_child()
            if sep is not None and self._children_remaining() > 0:
                self._write(sep)
        if final is not None:
            self._write(final)

    def _format_token(self):
        buf = self._script[self._node.start_byte:self._node.end_byte]
        self._write(buf)

    def _write(self, data):
        # Transparently indent at the beginning of lines, but only if we're not
        # writing a newline anyway.
        if not data.startswith(b'\n'):
            self._write_indent()
        self._ostream.write(data)

    def _write_indent(self):
        if self._ostream.get_column() == 0:
            self._ostream.write(b'\t' * self._indent)

    def _write_sp(self, num=1):
        self._write(b' ' * num)

    def _write_nl(self, num=1):
        self._write(b'\n' * num)

    def _is_comment(self, offset=0):
        node = self._get_child(offset=offset, skip_comments=False)
        return node and node.is_comment()

    def _is_post_comment(self, offset=0):
        node = self._get_child(offset=offset, skip_comments=False)
        return node and node.is_post_comment()

    def _children_remaining(self):
        remaining = 0
        for child in self._node.children[self._cidx:]:
            if not child.is_comment():
                remaining += 1
        return remaining

    def _get_child(self, offset=0, skip_comments=True):
        """Accessor for child nodes, without adjusting the offset index.

        Without additional options, it returns the current child node, ignoring
        any comment nodes. When using the offset argument, returns children
        before/after the current child. If setting skip_comments=False, it does
        not skip comment nodes.
        """
        direction = 1 if offset >= 0 else -1
        offset = abs(offset)

        for child in self._node.children[self._cidx::direction]:
            if not skip_comments or not child.is_comment():
                if offset == 0:
                    return child
                offset -= 1

        return None

    def _get_child_type(self, offset=0, skip_comments=True):
        """Returns the type ("decl", "stmt", etc) of the current child node.

        When integer offset is provided, returns node before/after the current
        child (e.g., offset=-1 means the node before the current child).
        Transparently skips any comment nodes, unless skip_comments=False.
        Never adjusts the child offset index. The returned type might refer to
        a named node or a literal token, Returns '' when no matching node exists.
        """
        try:
            return self._get_child(offset, skip_comments).type
        except AttributeError:
            return ''

    @staticmethod
    def register(symbol_name, klass, addl_args=None):
        return MAP.register(symbol_name, klass, addl_args)

    @staticmethod
    def lookup(node):
        # If we're looking up a token node, automatically fall back
        # to a dummy formatter.
        if not node.is_named:
            return Formatter, {}
        return MAP.get(node.type)


class LineFormatter(Formatter):
    def format(self):
        if self._node.children:
            self._format_children(b' ', b'\n')
        else:
            self._format_token()


class SpaceSeparatedFormatter(Formatter):
    def format(self):
        if self._node.children:
            self._format_children(b' ')
        else:
            self._format_token()


class TypechangeFormatter(Formatter):
    """A formatter that issues a newline after formatting when the next sibling
    node has a different type, or isn't among a given list of types. This helps
    with grouping "similar" nodes tightly, adding an extra newline only when a
    group finishes.
    """
    def __init__(self, script, node, ostream, indent=0, parent=None, typelist=None):
        super().__init__(script, node, ostream, indent, parent)
        self._typelist = typelist

    def format(self):
        super().format()
        if self._next_sibling_typechange():
            self._write_nl()

    def _next_sibling_typechange(self):
        # There's no type change when there's nothing to compare to, or that
        # thing isn't a complex node (for example, a '}' at the end of an export
        # block).
        if self._node.next_sibling is None or not self._node.next_sibling.is_named:
            return False

        nextsib = self._node.next_sibling

        if self._typelist and nextsib.type not in self._typelist:
            return False

        if nextsib.type == self._node.type:
            # For sequences of 'decl' this isn't very meaningful, so look at
            # the children to decide.
            try:
                if (self._node.type == 'decl' and
                    self._node.children[0].type != nextsib.children[0].type):
                    return True
            except IndexError:
                pass

            # Always separate uncommented record type definitions. (Comments
            # already trigger a separate newline, since they count as a type
            # change relative to decls.)
            def is_record_decl(node):
                try:
                    return (node.children[0].type == 'type_decl' and
                            node.children[0].children[3].children[0].type == 'record')
                except IndexError:
                    return False

            if is_record_decl(self._node) or is_record_decl(nextsib):
                return True

            # Always separate functions, events, hooks with extra whitespace
            def is_func_decl(node):
                try:
                    return node.type == 'decl' and node.children[0].type == 'func_decl'
                except IndexError:
                    return False

            if is_func_decl(self._node) or is_func_decl(nextsib):
                return True

            return False

        return True


class ModuleDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'module'
        self._write_sp()
        self._format_child_range(2) # <name> ';'
        self._write_nl()


class ExportDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'export'
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        while self._get_child_type() == 'decl':
            self._format_child(indent=True)
        self._format_child() # '}'
        self._write_nl()


class TypedInitializerFormatter(Formatter):
    """Helper for common construct that's not a separate symbol in the grammar:
    [:<type>] [<initializer] [attributes]
    """
    def _format_typed_initializer(self):
        if self._get_child_type() == ':':
            self._format_child() # ':'
            self._write_sp()
            self._format_child() # <type>

        if self._get_child_type() == 'initializer':
            self._write_sp()
            self._format_child() # <initializer>

        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child()


class GlobalDeclFormatter(TypedInitializerFormatter):
    """A formatter for the global-like symbols (global, option, const, simple
    value redefs), which all layout similarly.
    """
    def format(self):
        self._format_child() # "global", "option", etc
        self._write_sp()
        self._format_child() # <id>
        self._format_typed_initializer()
        self._format_child() # ';'
        self._write_nl()


class InitializerFormatter(Formatter):
    def format(self):
        if self._get_child_type() == 'init_class':
            self._format_child() # '=', '+=', etc
            self._write_sp()

        self._format_child() # <init>

class InitFormatter(Formatter):
    def format(self):
        if self._get_child_type() == '{':
            self._format_child() # '{'
            # Any number of expressions, comma-separated
            if self._get_child_type() == 'expr':
                self._write_nl()
                while self._get_child_type() == 'expr':
                    self._format_child(indent=True) # <expr>
                    if self._get_child_type() == ',':
                        self._format_child() # ','
                    self._write_nl()
            else:
                self._write_sp()
            self._format_child() # '}'
        else:
            self._format_child() # <expr>


class RedefEnumDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'redef'
        self._write_sp()
        self._format_child() # 'enum'
        self._write_sp()
        self._format_child() # <id>
        self._write_sp()
        self._format_child() # '+='
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        self._format_child(indent=True) # enum_body
        self._format_child_range(2) # '}' ';'
        self._write_nl()


class RedefRecordDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'redef'
        self._write_sp()
        self._format_child() # 'record'
        self._write_sp()
        self._format_child() # <id>
        self._write_sp()
        self._format_child() # '+='
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        while self._get_child_type() == 'type_spec': # any number of type_specs
            self._format_child(indent=True)
        self._format_child() # '}'
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>
        self._format_child() # ';'
        self._write_nl()


class TypeDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'type'
        self._write_sp()
        self._format_child_range(2) # <id> ':'
        self._write_sp()
        self._format_child() # <type>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>
        self._format_child() # ';'
        self._write_nl()


class TypeFormatter(SpaceSeparatedFormatter):
    def format(self):
        if self._get_child_type() == 'set':
            self._format_child() # 'set'
            self._format_child_range(3) # '[' ... ']'

        elif self._get_child_type() == 'table':
            self._format_child() # 'table'
            self._format_child_range(3) # '[' ... ']'
            self._write_sp()
            self._format_child() # 'of'
            self._write_sp()
            self._format_child() # <type>

        elif self._get_child_type() == 'record':
            self._format_child() # 'record',
            self._write_sp()
            self._format_child() # '{'

            if self._get_child_type() == 'type_spec': # any number of type_specs
                self._write_nl()
                while self._get_child_type() == 'type_spec':
                    self._format_child(indent=True)
            else:
                self._write_sp() # empty record, keep on one line

            self._format_child() # '}'

        elif self._get_child_type() == 'enum':
            self._format_child() # 'enum'
            self._write_sp()
            self._format_child() # '{'
            self._write_nl()
            self._format_child(indent=True) # enum_body
            self._format_child() # '}'

        elif self._get_child_type() == 'function':
            self._format_child_range(2) # 'function' <func_params>

        elif self._get_child_type() in ['event', 'hook']:
            self._format_child_range(2) # 'event'/'hook' '('
            if self._get_child_type() == 'formal_args':
                self._format_child()
            self._format_child() # ')'

        else:
            # Format anything else with plain space separation, e.g. "vector of foo"
            super().format()


class TypeSpecFormatter(Formatter):
    def format(self):
        self._format_child_range(2) # <id> ':'
        self._write_sp()
        self._format_child() # <type>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child()
        self._format_child() # ';'
        self._write_nl()


class EnumBodyFormatter(Formatter):
    def format(self):
        while self._get_child():
            self._format_child() # enum_body_elem
            if self._get_child():
                self._format_child() # ',' (optional at the end of the list)
            self._write_nl()


class FuncDeclFormatter(Formatter):
    def format(self):
        self._format_child() # <func_hdr>
        if self._get_child_type() == 'preproc':
            self._write_nl()
            while self._get_child_type() == 'preproc':
                self._format_child() # <preproc>
                self._write_nl()
        self._format_child() # <func_body>
        self._write_nl()

class FuncHdrFormatter(Formatter):
    def format(self):
        self._format_child() # <func>, <hook>, or <event>


class FuncHdrVariantFormatter(Formatter):
    def format(self):
        if self._get_child_type() == 'redef':
            self._format_child() # 'redef'
            self._write_sp()
        self._format_child() # 'function', 'hook', or 'event'
        self._write_sp()
        self._format_child() # <id>
        self._format_child() # <func_params>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>


class FuncParamsFormatter(Formatter):
    def format(self):
        self._format_child() # '('
        if self._get_child_type() == 'formal_args':
            self._format_child() # <formal_args>
        self._format_child() # ')'
        if self._get_child_type() == ':':
            self._format_child() # ':'
            self._write_sp()
            self._format_child() # <type>


class FuncBodyFormatter(Formatter):
    def format(self):
        self._write_sp()
        self._format_child() # '{'
        if self._get_child_type() == 'stmt_list':
            self._write_nl()
            self._format_child(indent=True) # <stmt_list>
        else:
            self._write_sp()
        self._format_child() # '}'


class FormalArgsFormatter(Formatter):
    def format(self):
        while self._get_child_type() == 'formal_arg':
            self._format_child() # <formal_arg>
            if self._get_child():
                self._format_child() # ',' or ';'
                self._write_sp()


class FormalArgFormatter(Formatter):
    def format(self):
        self._format_child_range(2) # <id> ':'
        self._write_sp()
        self._format_child() # <type>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>


class CaptureListFormatter(Formatter):
    def format(self):
        self._format_child() # '['
        while self._get_child_type() == 'capture':
            self._format_child() # <capture>
            if self._get_child_type() == ',':
                self._format_child() # ','
                self._write_sp()
        self._format_child() # ']'
        self._write_sp()


class StmtFormatter(TypedInitializerFormatter):
    def __init__(self, script, node, ostream, indent=0, parent=None):
        super().__init__(script, node, ostream, indent, parent)

        # It's an if/for/while statement with a "{ ... }" block
        self.has_curly_block = False

    def _child_is_curly_stmt(self):
        """Looks ahead to see if the upcoming statement is { ... }.
        This decides surrounding whitespace in some situations below.
        """
        try:
            res = self._get_child().children[0].type == '{'
            if res:
                self.has_curly_block = True
            return res
        except (AttributeError, IndexError):
            return False

    def _write_sp_or_nl(self):
        """Writes separator based on whether we have a curly block."""
        if self.has_curly_block:
            self._write_sp()
        else:
            self._write_nl()

    def _format_block(self):
        """Helper for formatting a statement that may be an { ... } block."""
        curly = self._child_is_curly_stmt()
        self._write_sp_or_nl()
        self._format_child(indent=not curly) # <stmt>
        if curly:
            self._write_nl()

    def _format_when(self):
        self._format_child() # 'when'
        self._write_sp()
        self._format_child() # '('
        self._write_sp()
        self._format_child() # <expr>
        self._write_sp()
        self._format_child() # ')'
        _ = self._child_is_curly_stmt()
        self._write_sp_or_nl()
        self._format_child(indent=True) # <stmt>

        if self._get_child_type() == 'timeout':
            self._format_child() # 'timeout'
            self._write_sp()
            self._format_child() # '{'
            if self._get_child_type() == 'stmt_list':
                self._write_nl()
                self._format_child(indent=True)
            else:
                self._write_sp()
            self._format_child() # '}'
            self._write_nl()

    def format(self):
        # Statements aren't currently broken down into more specific symbol
        # types in the grammer, so we just examine their beginning.
        start = self._get_child_type()
        if start == '{':
            self._format_child() # '{'
            if self._get_child_type() == 'stmt_list':
                self._write_nl()
                self._format_child(indent=True)
            else:
                self._write_sp()
            self._format_child() # '}'

        elif start in ['print', 'event']:
            self._format_child() # 'print'/'event'
            self._write_sp()
            self._format_child_range(2) # <expr_list>/<event_hdr> ';'
            self._write_nl()

        elif start == 'if':
            self._format_child() # 'if'
            self._write_sp()
            self._format_child() # '('
            self._write_sp()
            self._format_child() # <expr>
            self._write_sp()
            self._format_child() # ')'

            # We need to track whether the subsequent statement is a
            # curly-braces block for several reasons: we write a newline now
            # only when it's not, and we need to indent only if it's not such a
            # block (because it takes care of it internally). An else-block also
            # requires treatment.

            curly = self._child_is_curly_stmt()
            self._write_sp_or_nl()
            self._format_child(indent=not curly) # <stmt>

            if self._get_child_type() == 'else':
                if curly:
                    self._write_sp()
                self._format_child() # 'else'
                curly  = self._child_is_curly_stmt()
                self._write_sp_or_nl()
                self._format_child(indent=not curly) # <stmt>
                if curly:
                    self._write_nl()
            elif curly:
                self._write_nl() # Finish the if's curly block.

        elif start == 'switch':
            self._format_child() # 'switch'
            self._write_sp()
            self._format_child() # <expr>
            self._write_sp()
            self._format_child() # '{'
            if self._get_child_type() == 'case_list':
                self._format_child(indent=True) # <case_list>
            else:
                self._write_sp()
            self._format_child() # '}'
            self._write_nl()

        elif start == 'for':
            self._format_child() # 'for'
            self._write_sp()
            self._format_child() # '('
            self._write_sp()
            if self._get_child_type() == '[':
                self._format_child() # '['
                while self._get_child_type() != ']':
                    self._format_child() # <id>
                    if self._get_child_type() == ',':
                        self._format_child() # ','
                        self._write_sp()
                self._format_child() # ']'
            else:
                self._format_child() # <id>

            while self._get_child_type() == ',':
                self._format_child() # ','
                self._write_sp()
                self._format_child() # <id>
            self._write_sp()
            self._format_child() # 'in'
            self._write_sp()
            self._format_child() # <expr>
            self._write_sp()
            self._format_child() # ')'
            self._format_block() # <stmt>

        elif start == 'while':
            self._format_child() # 'while'
            self._write_sp()
            self._format_child() # '('
            self._write_sp()
            self._format_child() # <expr>
            self._write_sp()
            self._format_child() # ')'
            self._format_block() # <stmt>

        elif start in ['next', 'break', 'fallthrough']:
            self._format_child_range(2) # loop control statement, ';'
            self._write_nl()

        elif start == 'return':
            self._format_child() # 'return'
            # There's also an optional 'return" before when statements,
            # so detour in that case and be done.
            if self._get_child_type() == 'when':
                self._format_when()
                return
            if self._get_child_type() == 'expr':
                self._write_sp()
                self._format_child() # <expr>
            self._format_child() # ';'
            self._write_nl()

        elif start in ['add', 'delete']:
            self._format_child() # set management
            self._write_sp()
            self._format_child_range(2) # <expr> ';'
            self._write_nl()

        elif start in ['local', 'const']:
            self._format_child() # 'local'/'const'
            self._write_sp()
            self._format_child() # <id>
            self._format_typed_initializer()
            self._format_child() # ';'
            self._write_nl()

        elif start == 'when':
            self._format_when()

        elif start == 'index_slice':
            self._format_child() # <index_slice>
            self._write_sp()
            self._format_child() # '='
            self._write_sp()
            self._format_child_range(2) # <expr> ';'
            self._write_nl()

        elif start == 'expr':
            self._format_child_range(2) # <expr> ';'
            self._write_nl()

        elif start == 'preproc':
            self._format_child() # <preproc>
            self._write_nl()

        elif start == ';':
            self._format_child() # ';'
            self._write_nl()


class StmtListFormatter(Formatter):
    def format(self):
        while self._get_child_type() == 'stmt':
            cur_type = self._get_child().children[0].type

            self._format_child() # <stmt>

            # Ad-hoc stmt type comparison: if the statement's first symbol type
            # (e.g. "expr" vs "if") differs, we write a separator line, with few
            # exceptions. This keeps some statements un-separated, such as
            # sequences of expression statements (like function calls and
            # assignments). This usually looks fine but we may need to revisit
            # by typing additional expression classes explicitly.

            if self._get_child_type() != 'stmt':
                # Done with the statement list
                continue

            next_type = self._get_child().children[0].type

            # Loop control statements look odd with a blank line before them.
            if next_type in ['next', 'break', 'fallthrough', 'return']:
                continue

            # Separate statements when they have a curly block:
            if self.children[-1].has_curly_block:
                self._write_nl()
                continue

            if cur_type != next_type:
                self._write_nl()


class ExprListFormatter(Formatter):
    def format(self):
        while self._get_child_type() == 'expr':
            self._format_child() # <expr>
            if self._get_child():
                self._format_child() # ','
                self._write_sp()


class CaseListFormatter(Formatter):
    def format(self):
        while self._get_child():
            if self._get_child_type() == 'case':
                self._format_child() # 'case'
                self._write_sp()
                self._format_child_range(2) # <expr_list> or <case_type_list>, ':'
            else:
                self._format_child_range(2) # 'default' ':'
            self._write_nl()
            if self._get_child_type() == 'stmt_list':
                self._format_child(indent=True) # <stmt_list>


class CaseTypeListFormatter(Formatter):
    def format(self):
        while self._get_child_type() == 'type':
            self._format_child() # 'type'
            self._write_sp()
            self._format_child() # <type>
            if self._get_child_type() == 'as':
                self._write_sp()
                self._format_child() # 'as'
                self._write_sp()
                self._format_child() # <id>
            if self._get_child_type() == ',':
                self._format_child() # ','
                self._write_sp()


class EventHdrFormatter(Formatter):
    def format(self):
        self._format_child() # <id>
        self._format_child() # '('
        if self._get_child_type() == 'expr_list':
            self._format_child() # <expr_list>
        self._format_child() # ')'


class ExprFormatter(SpaceSeparatedFormatter):
    # Like statments, expressions aren't currently broken into specific symbol
    # types, so we parse into them to identify how to layout them.
    def format(self):
        ct1, ct2, ct3 = [self._get_child_type(offset=n) for n in (0,1,2)]

        if ct1 == 'expr' and ct2 in ['[', 'index_slice', '$']:
            while self._get_child():
                self._format_child()

        elif ct1 in ['|', '++', '--', '!', '~', '-', '+']:
            # No space when those operators are involved
            while self._get_child():
                self._format_child()

        elif ct1 == 'expr' and ct2 == '!' and ct3 == 'in':
            self._format_child() # <expr>
            self._write_sp()
            self._format_child_range(2) # '!in'
            self._write_sp()
            self._format_child() # <expr>

        elif ct1 == '[':
            self._format_child() # '['
            if self._get_child_type() == 'expr_list':
                self._format_child() # <expr_list>
            else:
                self._write_sp()
            self._format_child() # ']

        elif ct1 == '$':
            self._format_child_range(2) # '$'<id>
            self._write_sp()
            super().format() # Handle rest space-separated

        elif ct1 == '(':
            self._format_child_range(3) # '(' <expr> ')'

        elif ct1 == 'copy':
            self._format_child_range(4) # 'copy' '(' <expr> ')'

        elif ct2 == '?$':
            self._format_child_range(3) # <expr> '$?' <expr>

        elif ct2 == '(':
            # initializers such as table(...)
            self._format_child_range(2) # 'table(' etc
            if self._get_child_type() == 'expr_list':
                self._format_child()
            self._format_child() # ')'
            if self._get_child_type() == 'attr_list':
                self._write_sp()
                self._format_child()

        else:
            # Fall back to simple space-separation
            super().format()


class ZeekygenHeadCommentFormatter(TypechangeFormatter):
    def format(self):
        self._format_token()
        self._write_nl()
        if self._next_sibling_typechange():
            self._write_nl()


class ZeekygenNextCommentFormatter(Formatter):
    def format(self):
        self._format_token()
        self._write_nl()


class ZeekygenPrevCommentFormatter(Formatter):
    def __init__(self, script, node, ostream, indent=0, parent=None):
        super().__init__(script, node, ostream, indent, parent)
        self.column = 0 # Column at which this comment lives

    def format(self):
        # Handle indent explicitly here because of the transparent handling of
        # comments. If we don't call this, nothing may force the indent for the
        # comment if it's the only thing on the line.
        self._write_indent()

        if isinstance(self.prev, ZeekygenPrevCommentFormatter):
            self._write_sp(self.prev.column - self._ostream.get_column())
        else:
            self._write_sp()

        # Record the output column so potential subsequent Zeekygen
        # comments can use the same alignment.
        self.column = self._ostream.get_column()

        # Write comment itself
        self._format_token()


# ---- Explicit mappings for grammar symbols to formatters ---------------------
#
# NodeMapper.get() retrieves formatters not listed here by mapping symbol
# names to class names, e.g. module_decl -> ModuleDeclFormatter.

Formatter.register('decl', TypechangeFormatter)

# After minor comments we don't add an extra newline (so we group the comment
# with the thing that follows), unless we switch to a Zeekygen comment.
Formatter.register('minor_comment', TypechangeFormatter,
                   {'typelist': ['zeekygen_head_comment',
                                 'zeekygen_prev_comment',
                                 'zeekygen_next_comment']})

Formatter.register('preproc', LineFormatter)

Formatter.register('const_decl', GlobalDeclFormatter)
Formatter.register('global_decl', GlobalDeclFormatter)
Formatter.register('option_decl', GlobalDeclFormatter)
Formatter.register('redef_decl', GlobalDeclFormatter)

Formatter.register('func', FuncHdrVariantFormatter)
Formatter.register('hook', FuncHdrVariantFormatter)
Formatter.register('event', FuncHdrVariantFormatter)

Formatter.register('capture', SpaceSeparatedFormatter)
Formatter.register('attr_list', SpaceSeparatedFormatter)

# ---- Helper functions --------------------------------------------------------

def node_str(node, indent, script):
    content = ''
    if node.is_named:
        # Cap the amount we show in the tree ...
        content = script.source[node.start_byte:node.end_byte][:100]
        # ... and render it such that we get backslash-escapes.
        content = str(repr(content.decode('ascii', 'ignore')))
    return ' ' * (4*indent) + '{} ({}.{},{}.{}) {}'.format(
        node.type, node.start_point[0], node.start_point[1],
        node.end_point[0], node.end_point[1], content)

def create_parser():
    parser = argparse.ArgumentParser(description='A Zeek script analyzer')

    command_parser = parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    # format

    sub_parser = command_parser.add_parser(
        'format', help='Format/indent Zeek scripts')
    sub_parser.set_defaults(run_cmd=cmd_format)
    sub_parser.add_argument('--inplace', '-i', action='store_true',
                            help='change provided files instead of writing to stdout')
    sub_parser.add_argument('scripts', metavar='FILES', action='append',
                            help='Zeek script(s) to process.')

    # parse

    sub_parser = command_parser.add_parser(
        'parse', help='Show Zeek script parse tree')
    sub_parser.set_defaults(run_cmd=cmd_parse)
    sub_parser.add_argument('script', metavar='FILE',
                            help='Zeek script to parse.')

    return parser

# ---- CLI commands ------------------------------------------------------------

def cmd_format(args):
    for fname in args.scripts:
        ofname = fname if args.inplace else None
        script = Script(fname, ofname)
        script.parse()
        script.format()

    return 0

def cmd_parse(args):
    script = Script(args.script)
    script.parse()

    for node, indent in script.traverse():
        print(node_str(node, indent, script))

    return 0

def main():
    parser = create_parser()
    args = parser.parse_args()

    if not args.command:
        print('error: please provide a command to execute. See --help.')
        return 1

    try:
        return args.run_cmd(args)
    except KeyboardInterrupt:
        return 0

if __name__ == '__main__':
    sys.exit(main())
