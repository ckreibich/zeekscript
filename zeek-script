#! /usr/bin/env python
"""
This is a tool for processing Zeek scripts. It currently supports formatting
scripts according to codified rules (no optionas at all atm), and showing a
parse tree for the script.
"""
# PYTHON_ARGCOMPLETE_OK
import argparse
import io
import sys
import traceback

try:
    # Argcomplete provides command-line completion for users of argparse.
    # We support it if available, but don't complain when it isn't.
    import argcomplete
except:
    pass

import zeekscript

# ---- Helper functions --------------------------------------------------------

def print_error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def node_str(node, indent, script):
    content = ''
    if node.is_named:
        # Cap the amount we show in the tree ...
        content = script.source[node.start_byte:node.end_byte][:100]
        # ... and render it such that we get backslash-escapes.
        content = str(repr(content.decode('ascii', 'ignore')))

    cst_indicator = ''
    if not node.is_ast:
        if node.is_cst_prev_node:
            cst_indicator = 'v '
        if node.is_cst_next_node:
            cst_indicator = '^ '

    return ' ' * (4*indent) + '{}{} ({}.{},{}.{}) {}'.format(
        cst_indicator, node.type,
        node.start_point[0], node.start_point[1],
        node.end_point[0], node.end_point[1],
        content)

def create_parser():
    parser = argparse.ArgumentParser(description='A Zeek script analyzer')
    command_parser = parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    file_help = ('Use "-" to specify stdin as a filename. Omitting '
                 'filenames entirely implies reading from stdin.')

    # format

    sub_parser = command_parser.add_parser(
        'format', help='Format/indent Zeek scripts')

    sub_parser.set_defaults(run_cmd=cmd_format)
    sub_parser.add_argument(
        '--inplace', '-i', action='store_true',
        help='change provided files instead of writing to stdout')
    sub_parser.add_argument(
        'scripts', metavar='FILES', nargs='*',
        help='Zeek script(s) to process. ' + file_help)

    # parse

    sub_parser = command_parser.add_parser(
        'parse', help='Show Zeek script parse tree')
    sub_parser.set_defaults(run_cmd=cmd_parse)
    sub_parser.add_argument(
        '--concrete', '-c', action='store_true',
        help='report concrete syntax tree (CST) instead of AST')
    sub_parser.add_argument(
        'script', metavar='FILE', nargs='?',
        help='Zeek script to parse. ' + file_help)

    if 'argcomplete' in sys.modules:
        argcomplete.autocomplete(parser)

    return parser

# ---- CLI commands ------------------------------------------------------------

def cmd_format(args):
    if not args.scripts:
        args.scripts = ['-']

    def do_write(source):
        with open(ofname, 'w') if ofname else sys.stdout as ostream:
            ostream.write(source.decode('UTF-8'))

    for fname in args.scripts:
        inplace = args.inplace
        if fname == '-' and inplace:
            print_error('warning: ignoring --inplace when reading from stdin')
            inplace = False

        script = zeekscript.Script(fname)
        ofname = fname if inplace else None

        try:
            script.parse()
        except zeekscript.Error as err:
            print_error('parsing error: ' + str(err))
            do_write(script.source)
            return 1
        except Exception as err:
            print_error('internal error: ' + str(err))
            traceback.print_exc(file=sys.stderr)
            do_write(script.source)
            return 1

        buf = io.BytesIO()

        try:
            script.format(buf)
        except Exception as err:
            print_error('internal error: ' + str(err))
            traceback.print_exc(file=sys.stderr)
            do_write(script.source)
            return 1

        # Write out the complete, reformatted source.
        do_write(buf.getvalue())

    return 0

def cmd_parse(args):
    script = zeekscript.Script(args.script or '-')

    try:
        script.parse()
    except zeekscript.ParserError as err:
        print_error('parsing error: ' + str(err))
        print_error('starting line: ' + err.line)
        return 1
    except zeekscript.Error as err:
        print_error('error: ' + str(err))
        return 1

    for node, indent in script.traverse(include_cst=args.concrete):
        print(node_str(node, indent, script))

    return 0

def main():
    parser = create_parser()
    args = parser.parse_args()

    if not args.command:
        print_error('error: please provide a command to execute. See --help.')
        return 1

    try:
        return args.run_cmd(args)
    except KeyboardInterrupt:
        return 0

if __name__ == '__main__':
    sys.exit(main())
