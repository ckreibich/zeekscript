#! /usr/bin/env python

import argparse
import sys

try:
    from tree_sitter import Language, Parser
except ImportError:
    print('This script requires the tree_sitter package.')
    sys.exit(1)

# Build and initialize the tree-sitter parser. This becomes a no-op when the
# parser needs no re-building. We specify the library build location and the
# language(s) to include.
Language.build_library('build/zeek-language.so', ['tree-sitter-zeek'])
ZEEK_LANGUAGE = Language('build/zeek-language.so', 'zeek')
ZEEK_PARSER = Parser()
ZEEK_PARSER.set_language(ZEEK_LANGUAGE)

class Node:
    def __init__(self):
        self.children = []
        self.parent = None
        self.prev_sibling = None
        self.next_sibling = None
        self.start_byte = 0
        self.end_byte = 0
        self.start_point = (0, 0)
        self.end_point = (0, 0)
        self.is_named = False
        self.type = None


class NodeMapper:
    def __init__(self):
        self._map = {}

    def register(self, symbol_name, klass, addl_args=None):
        self._map[symbol_name] = (klass, addl_args or {})

    def get(self, symbol_name):
        try:
            return self._map[symbol_name]
        except KeyError:
            return Formatter, {}

MAP = NodeMapper()


class OutputStream:
    """A column-aware wrapper for output streams."""
    def __init__(self, ostream):
        self._ostream = ostream
        self._col = 0

    def write(self, data):
        for chunk in data.splitlines(keepends=True):
            self._ostream.buffer.write(chunk)
            self._col += len(chunk)
            if chunk.endswith(b'\n'):
                self._col = 0

    def get_column(self):
        return self._col


class Script:
    def __init__(self, fname, ofname=None):
        # The file name to read the Zeek script from
        self.name = fname
        # The file's full content
        self.source = None
        # The tree-sitter parse tree for the script
        self.tree = None
        # The root node of our cloned (and malleable) tree
        self.root = None
        # The output file name -- None if stdout
        self.ofname = ofname

    def parse(self):
        with open(self.name, 'rb') as hdl:
            self.source = hdl.read()
            self.tree = ZEEK_PARSER.parse(self.source)
            self._clone_tree()
            self._patchup_tree()

    def traverse(self):
        def visit(node):
            queue = [(node, 0)]
            while queue:
                node, indent = queue.pop(0)
                yield node, indent
                for child in reversed(node.children):
                    queue.insert(0, (child, indent+1))

        assert self.root is not None, 'call Script.parse() before Script.traverse()'
        for node, indent in visit(self.root):
            yield node, indent

    def __getitem__(self, key):
        return self.source.__getitem__(key)

    def format(self):
        assert self.root is not None, 'call Script.parse() before Script.format()'
        with open(self.ofname, 'wb') if self.ofname else sys.stdout as ostream:
            fclass, _ = Formatter.lookup(self.root)
            formatter = fclass(self, self.root, OutputStream(ostream))
            formatter.format()

    def _clone_tree(self):
        """The tree_sitter tree isn't malleable from Python. This clones it to a tree of
        our own Node class that we can alter freely.
        """
        def make_node(node):
            new_node = Node()
            new_node.start_byte, new_node.end_byte = node.start_byte, node.end_byte
            new_node.start_point, new_node.end_point = node.start_point, node.end_point
            new_node.is_named = node.is_named
            new_node.type = node.type

            for child in node.children:
                new_child = make_node(child)
                new_child.parent = new_node
                new_node.children.append(new_child)
                if len(new_node.children) > 1:
                    new_node.children[-2].next_sibling = new_node.children[-1]
                    new_node.children[-1].prev_sibling = new_node.children[-2]

            return new_node

        self.root = make_node(self.tree.root_node)

    def _patchup_tree(self):
        """Make any modifications to the syntax tree we require for our processing."""

        # Move any dangling zeekygen_prev_comments down into the tree so they
        # directly child-follow the node that the comment refers to. For
        # example, this turns ...
        #
        #   type_spec (138.1,138.15)
        #       id (138.1,138.9)
        #       : (138.9,138.10)
        #       type (138.11,138.14)
        #           int (138.11,138.14)
        #           ; (138.14,138.15)
        #       zeekygen_prev_comment (138.19,139.0) '##< A comment explaining the int\n'
        #       zeekygen_prev_comment (139.19,140.0) '##< continuing here.\n'
        #
        # ... into this:
        #
        #   type_spec (138.1,138.15)
        #       id (138.1,138.9)
        #       : (138.9,138.10)
        #       type (138.11,138.14)
        #           int (138.11,138.14)
        #           ; (138.14,138.15)
        #           zeekygen_prev_comment (138.19,139.0) '##< A comment explaining the int\n'
        #           zeekygen_prev_comment (139.19,140.0) '##< continuing here.\n'
        #
        for node, _ in self.traverse():
            idx = 0 # Iterate manually since not every iteration advances idx
            while idx < len(node.children):
                child = node.children[idx]
                # If this child is a ##< comment and the previous child has
                # children, move the comment down to the kid's kids.
                if (idx > 0 and child.type == 'zeekygen_prev_comment' and
                    node.children[idx-1].children):

                    # Cut out comment from sibling relationships:
                    child.prev_sibling.next_sibling = child.next_sibling
                    if child.next_sibling:
                        child.next_sibling.prev_sibling = child.prev_sibling

                    # Move comment to new location:
                    node.children.pop(idx)
                    node.children[idx-1].children.append(child)

                    # Adjust sibling relationship in new location:
                    if len(node.children[idx-1].children) > 1:
                        node.children[idx-1].children[-2].next_sibling = child
                        child.prev_sibling = node.children[idx-1].children[-2]
                else:
                    idx += 1


# ---- Symbol formatters -----------------------------------------------

class Formatter:
    def __init__(self, script, node, ostream, indent=0, parent=None):
        self._script = script
        self._node = node
        self._ostream = ostream
        self._indent = indent

        # Child node index for iteration
        self._cidx = 0

        # Like tree_sitter.Node we use a parent/children structure, so a given
        # formatter can access formatting state in its surroundings. 
        self._parent = parent
        self._next = None
        self._prev = None
        self._children = []

    def format(self):
        if self._node.children:
            self._format_children()
        else:
            self._format_token()

    def _next_child(self):
        try:
            node = self._node.children[self._cidx]
            self._cidx += 1
            return node
        except IndexError:
            return None

    def _format_child_impl(self, indent):
        node = self._next_child()

        fclass, addl_args = Formatter.lookup(node)
        formatter = fclass(self._script, node, self._ostream,
                           indent=self._indent + int(indent),
                           parent=self, **addl_args)

        if self._children:
            self._children[-1]._next = formatter
            formatter._prev = self._children[-1]

        self._children.append(formatter)

        formatter.format()

    def _format_child(self, indent=False):
        # Skip comments transparently, as they can occur anywhere.
        while self._is_comment():
            self._format_child_impl(indent=indent)

        self._format_child_impl(indent=indent)

        # After the child, also skip Zeekygen post-comments (##<):
        while self._is_post_comment():
            self._format_child_impl(indent=indent)
            if self._is_post_comment():
                self._write_nl()

    def _format_child_range(self, num, indent=False):
        for _ in range(num):
            self._format_child(indent)

    def _format_children(self, sep=None, final=None):
        while self._children_remaining():
            self._format_child()
            if sep is not None and self._children_remaining() > 0:
                self._write(sep)
        if final is not None:
            self._write(final)

    def _format_token(self):
        buf = self._script[self._node.start_byte:self._node.end_byte]
        self._write(buf)

    def _write(self, data):
        # Transparently indent at the beginning of lines, but only if we're not
        # writing a newline anyway.
        if not data.startswith(b'\n'):
            self._write_indent()
        self._ostream.write(data)

    def _write_indent(self):
        if self._ostream.get_column() == 0:
            self._ostream.write(b'\t' * self._indent)

    def _write_sp(self, num=1):
        self._write(b' ' * num)

    def _write_nl(self, num=1):
        self._write(b'\n' * num)

    def _is_comment_node(self, node):
        return node and node.type.endswith('_comment')

    def _is_comment(self, offset=0):
        return self._is_comment_node(
            self._get_child(offset=offset, skip_comments=False))

    def _is_post_comment_node(self, node):
        return node and node.type == 'zeekygen_prev_comment'

    def _is_post_comment(self, offset=0):
        return self._is_post_comment_node(
            self._get_child(offset=offset, skip_comments=False))

    def _children_remaining(self):
        remaining = 0
        for child in self._node.children[self._cidx:]:
            if not self._is_comment_node(child):
                remaining += 1
        return remaining

    def _get_child(self, offset=0, skip_comments=True):
        """Accessor for child nodes, without adjusting the offset index. Without
        additional options, it returns the current child node, ignoring any
        comment nodes. When using the offset argument, returns children
        before/after the current child. If setting skip_comments=False, it does
        not skip comment nodes.
        """
        direction = 1 if offset >= 0 else -1
        offset = abs(offset)

        for child in self._node.children[self._cidx::direction]:
            if not skip_comments or not self._is_comment_node(child):
                if offset == 0:
                    return child
                offset -= 1

        return None

    def _get_child_type(self, offset=0, skip_comments=True):
        """Returns the type ("decl", "stmt", etc) of the current child node (skipping
        any potential comments) without adjusting the index, or None if there is
        no more child node.
        """
        try:
            return self._get_child(offset, skip_comments).type
        except AttributeError:
            return ''

    @staticmethod
    def register(symbol_name, klass, addl_args=None):
        return MAP.register(symbol_name, klass, addl_args)

    @staticmethod
    def lookup(node):
        # If we're looking up a token node, automatically fall back
        # to a dummy formatter.
        if not node.is_named:
            return Formatter, {}
        return MAP.get(node.type)


class LineFormatter(Formatter):
    def format(self):
        if self._node.children:
            self._format_children(b' ', b'\n')
        else:
            self._format_token()


class SpaceSeparatedFormatter(Formatter):
    def format(self):
        if self._node.children:
            self._format_children(b' ')
        else:
            self._format_token()


class TypechangeNewlineFormatter(Formatter):
    """A formatter that issues a newline after formatting when the next sibling
    node has a different type, or isn't among a given list of types. This helps
    with grouping "similar" nodes tightly, adding an extra newline only when a
    group finishes.
    """
    def __init__(self, script, node, ostream, indent=0, parent=None, typelist=None):
        super().__init__(script, node, ostream, indent, parent)
        self._typelist = typelist

    def format(self):
        super().format()
        if self._next_sibling_typechange():
            self._write_nl()

    def _next_sibling_typechange(self):
        # There's no type change when there's nothing to compare to, or that
        # thing isn't a complex node (for example, a '}' at the end of an export
        # block).
        if self._node.next_sibling is None or not self._node.next_sibling.is_named:
            return False

        next = self._node.next_sibling

        if self._typelist and next.type not in self._typelist:
            return False

        if next.type == self._node.type:
            # For sequences of 'decl' this isn't very meaningful, so look more
            # closely. If the types of decls differ, it counts.
            try:
                if (self._node.type == 'decl' and
                    self._node.children[0].type != next.children[0].type):
                    return True
            except IndexError:
                pass

            # Always separate uncommented record type definitions. (Comments
            # already trigger a separate newline, since they count as a type
            # change relative to decls.)
            def is_record_type_decl(node):
                try:
                    return (node.children[0].type == 'type_decl' and
                            node.children[0].children[3].children[0].type == 'record')
                except IndexError:
                    return False

            if is_record_type_decl(self._node) or is_record_type_decl(next):
                return True

            return False

        return True


class ModuleDeclFormatter(Formatter):
    def format(self):
        self._write_nl()
        self._format_child() # 'module'
        self._write_sp()
        self._format_child_range(2) # <name> ';'
        self._write_nl(2)


class ExportDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'export'
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        while self._get_child_type() == 'decl':
            self._format_child(indent=True)
        self._format_child() # '}'
        self._write_nl()


class GlobalDeclFormatter(Formatter):
    """A formatter for the global-like symbols (global, option, const, simple
    value redefs), which all layout similarly.
    """
    def format(self):
        self._format_child() # "global", "option", etc
        self._write_sp()
        self._format_child() # <id>

        if self._get_child_type() == ':':
            self._format_child() # ':'
            self._write_sp()
            self._format_child() # <type>

        if self._get_child_type() == 'initializer':
            self._write_sp()
            self._format_child() # <initializer>

        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child()

        self._format_child() # ';'
        self._write_nl()


class InitializerFormatter(Formatter):
    def format(self):
        if self._get_child_type() == 'init_class':
            self._format_child() # '=', '+=', etc
            self._write_sp()

        self._format_child() # <init>

class InitFormatter(Formatter):
    def format(self):
        if self._get_child_type() == '{':
            self._format_child() # '{'
            while self._get_child_type() != '}':
                self._format_child() # <expr>
                if self._get_child_type() == ',':
                    self._format_child() # ','
                    self._write_sp()
            self._format_child() # '}'
        else:
            self._format_child() # <expr>


class RedefEnumDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'redef'
        self._write_sp()
        self._format_child() # 'enum'
        self._write_sp()
        self._format_child() # <id>
        self._write_sp()
        self._format_child() # '+='
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        self._format_child(indent=True) # enum_body
        self._format_child_range(2) # '}' ';'
        self._write_nl()


class RedefRecordDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'redef'
        self._write_sp()
        self._format_child() # 'record'
        self._write_sp()
        self._format_child() # <id>
        self._write_sp()
        self._format_child() # '+='
        self._write_sp()
        self._format_child() # '{'
        self._write_nl()
        while self._get_child_type() == 'type_spec': # any number of type_specs
            self._format_child(indent=True)
        self._format_child() # '}'
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>
        self._format_child() # ';'
        self._write_nl()


class TypeDeclFormatter(Formatter):
    def format(self):
        self._format_child() # 'type'
        self._write_sp()
        self._format_child_range(2) # <id> ':'
        self._write_sp()
        self._format_child() # <type>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child() # <attr_list>
        self._format_child() # ';'
        self._write_nl()


class TypeFormatter(SpaceSeparatedFormatter):
    PAREN_LIST_TYPES = set(['function', 'event', 'hook'])

    def format(self):
        if self._get_child_type() == 'set':
            self._format_child() # 'set'
            self._format_child_range(3) # '[' ... ']'

        elif self._get_child_type() == 'table':
            self._format_child() # 'table'
            self._format_child_range(3) # '[' ... ']'
            self._write_sp()
            self._format_child() # 'of'
            self._write_sp()
            self._format_child() # <type>

        elif self._get_child_type() == 'record':
            self._format_child() # 'record',
            self._write_sp()
            self._format_child() # '{'
            self._write_nl()

            while self._get_child_type() == 'type_spec': # any number of type_specs
                self._format_child(indent=True)

            self._format_child() # '}'

        elif self._get_child_type() == 'enum':
            self._format_child() # 'enum'
            self._write_sp()
            self._format_child() # '{'
            self._write_nl()
            self._format_child(indent=True) # enum_body
            self._format_child() # '}'

        else:
            # Format anything else with plain space separation, e.g. "vector of foo"
            super().format()


class TypeSpecFormatter(Formatter):
    def format(self):
        self._format_child_range(2) # <id> ':'
        self._write_sp()
        self._format_child() # <type>
        if self._get_child_type() == 'attr_list':
            self._write_sp()
            self._format_child()
        self._format_child() # ';'
        self._write_nl()


class EnumBodyFormatter(Formatter):
    def format(self):
        while self._get_child():
            self._format_child() # enum_body_elem
            if self._get_child():
                self._format_child() # ',' (optional at the end of the list)
            self._write_nl()


class ZeekygenCommentFormatter(Formatter):
    def format(self):
        self._format_token()
        self._write_nl()


class ZeekygenPrevCommentFormatter(ZeekygenCommentFormatter):
    def __init__(self, script, node, ostream, indent=0, parent=None):
        super().__init__(script, node, ostream, indent, parent)
        self._column = 0 # Column at which this comment lives

    def format(self):
        # Handle indent explicitly here because of the transparent handling of
        # comments. If we don't call this, nothing may force the indent for the
        # comment if it's the only thing on the line.
        self._write_indent()

        if isinstance(self._prev, ZeekygenPrevCommentFormatter):
            self._write_sp(self._prev._column - self._ostream.get_column())
        else:
            self._write_sp()

        # Record the output column so potential subsequent Zeekygen
        # comments can use the same alignment.
        self._column = self._ostream.get_column()

        # Write comment itself
        self._format_token()


# ---- Map grammar symbols to formatters -------------------------------

Formatter.register('decl', TypechangeNewlineFormatter)
Formatter.register('module_decl', ModuleDeclFormatter)
Formatter.register('export_decl', ExportDeclFormatter)

# After minor comments we don't add an extra newline (to group the comment
# with the thing that follows), unless we switch to a Zeekygen comment.
Formatter.register('minor_comment', TypechangeNewlineFormatter,
                   {'typelist': ['zeekygen_head_comment',
                                 'zeekygen_prev_comment',
                                 'zeekygen_next_comment']})

Formatter.register('zeekygen_head_comment', ZeekygenCommentFormatter)
Formatter.register('zeekygen_next_comment', ZeekygenCommentFormatter)
Formatter.register('zeekygen_prev_comment', ZeekygenPrevCommentFormatter)

Formatter.register('preproc', LineFormatter)

Formatter.register('type_decl', TypeDeclFormatter)
Formatter.register('type', TypeFormatter)
Formatter.register('type_spec', TypeSpecFormatter)
Formatter.register('enum_body', EnumBodyFormatter)

Formatter.register('const_decl', GlobalDeclFormatter)
Formatter.register('global_decl', GlobalDeclFormatter)
Formatter.register('option_decl', GlobalDeclFormatter)
Formatter.register('redef_decl', GlobalDeclFormatter)
Formatter.register('redef_enum_decl', RedefEnumDeclFormatter)
Formatter.register('redef_record_decl', RedefRecordDeclFormatter)

Formatter.register('initializer', InitializerFormatter)
Formatter.register('init', InitFormatter)

# ---- Helper functions ------------------------------------------------

def node_str(node, indent, script):
    content = ''
    if node.is_named:
        # Cap the amount we show in the tree ...
        content = script.source[node.start_byte:node.end_byte][:100]
        # ... and render it such that we get backslash-escapes.
        content = str(repr(content.decode('ascii', 'ignore')))
    return ' ' * (4*indent) + '{} ({}.{},{}.{}) {}'.format(
        node.type, node.start_point[0], node.start_point[1],
        node.end_point[0], node.end_point[1], content)

def create_parser():
    parser = argparse.ArgumentParser(description='A Zeek script analyzer')

    command_parser = parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    # format

    sub_parser = command_parser.add_parser(
        'format', help='Format/indent Zeek scripts')
    sub_parser.set_defaults(run_cmd=cmd_format)
    sub_parser.add_argument('--inplace', '-i', action='store_true',
                            help='change provided files instead of writing to stdout')
    sub_parser.add_argument('scripts', metavar='FILES', action='append',
                            help='Zeek script(s) to process.')

    # parse

    sub_parser = command_parser.add_parser(
        'parse', help='Show Zeek script parse tree')
    sub_parser.set_defaults(run_cmd=cmd_parse)
    sub_parser.add_argument('script', metavar='FILE',
                            help='Zeek script to parse.')

    return parser

# ---- CLI commands ----------------------------------------------------

def cmd_format(args):
    for fname in args.scripts:
        ofname = fname if args.inplace else None
        script = Script(fname, ofname)
        script.parse()
        script.format()

    return 0

def cmd_parse(args):
    script = Script(args.script)
    script.parse()

    for node, indent in script.traverse():
        print(node_str(node, indent, script))

    return 0

def main():
    parser = create_parser()
    args = parser.parse_args()

    if not args.command:
        print('error: please provide a command to execute. See --help.')
        return 1

    try:
        return args.run_cmd(args)
    except KeyboardInterrupt:
        return 0

if __name__ == '__main__':
    sys.exit(main())
